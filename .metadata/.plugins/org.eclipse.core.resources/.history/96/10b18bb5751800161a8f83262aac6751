#include "bsp.h"

/*
 * LCD koordináták:
 *
 * |----------|-----------|
 * |          |           |
 * |  chip 1  |   chip2   |
 * |          |           ^
 * |----------|-------<---| page = 0
 *                       ^
 *                       |
 *                    Column = 0
 *
 */

/*
 * LCD-re rajzoló függvények.
 */
void InitLcd()
{
	LcdReset(1);
	LcdReset(0);

	SetInstructionReg();
	SetDataDirOut();
	SelectChip1();
	WriteData(DISPLAY_ON); // Bekapcsoljuk a kijelzõt.
	SelectChip2();
	WriteData(DISPLAY_ON);
}

void TogglePieces()
{
	static uint8_t DisplayState = 1;
	DisplayState = !DisplayState;

#ifdef TOGGLE_FULL_SCREEN
	SetInstructionReg();
	SelectChip1();
	WriteData(DISPLAY_OFF + DisplayState);
	SelectChip2();
	WriteData(DISPLAY_OFF + DisplayState);
#else
	if(DisplayState) DrawTable(PATTERN_ON,NO_SCROLL); // A bábuk villogtatásával, csúsztatás nélkül újrarajzoljuk a táblát.
	else DrawTable(PATTERN_OFF,NO_SCROLL);
#endif
}

void WaitBusy() // Megvárjuk, amíg mind a kettõ chip nincs kész állapotban.
{
	volatile int i;
	// Lementjük a kiválasztott regisztert.
	int di = HAL_GPIO_ReadPin(DIPort,DI);

	SetDataDirIn();
	SetInstructionReg();

		i = 1;
		while(i) //Addig várunk, amíg a Busy Flag értéke nem 0.
			{
				SetE();
				i = HAL_GPIO_ReadPin(DPort,DB7);
				ClearE();
			}

	HAL_GPIO_WritePin(DIPort,DI,(di==0 ? GPIO_PIN_RESET : GPIO_PIN_SET));
	SetDataDirOut(); // Az alapértelmezett irány az output, így visszafordítjuk az adatvonalakat.
}

char Pattern[6][8]= // Bábuk mintázata
{
		//{0xFF,0x99,0xBD,0xFF,0xFF,0xBD,0x99,0xFF}, //kör
		{0xFF,0x81,0x99,0xBD,0xBD,0x99,0x81,0xFF}, //kör
		//{0x00,0x18,0x3C,0x7E,0x7E,0x3C,0x18,0x0}, //kör KERET NÉLKÜL
		{0xFF,0x99,0xBD,0xE7,0xE7,0xBD,0x99,0xFF}, // kör király
		{0xFF,0x81,0xBD,0xBD,0xBD,0xBD,0x81,0xFF}, // négyzet
		{0xFF,0x81,0xBD,0xA5,0xA5,0xBD,0x81,0xFF}, //négyzet király
		{0xFF,0x81,0x81,0x81,0x81,0x81,0x81,0xFF}, //üres mezõ
		{0xFF,0x81,0x81,0x99,0x99,0x81,0x81,0xFF}  // kiindulasi pont
};

void ShowPlayerSignal(uint8_t player) //Kirajzoljuk a képernyõ 2 oldalára az aktuális játékos bábuját.
{
	FigureType fig;
	int k;
	if(player == 0) fig = KOR;
	else fig = NEGYZET;

	SelectChip2();
	SetInstructionReg();
	WriteData(PAGE_ADDRESS + 6);
	WriteData(COLUMN_ADDRESS + 13);
	SetDataReg();
	for(k=1;k<7;k++) WriteData(Pattern[fig][k]&0x7E);

	SelectChip1();
	SetInstructionReg();
	WriteData(PAGE_ADDRESS + 6);
	WriteData(COLUMN_ADDRESS + 13+32);
	SetDataReg();
	for(k=1;k<7;k++) WriteData(Pattern[fig][k]&0x7E);
}

void SetupScreen()
{
	// Teljesen kitöröljük a képernyõ tartalmát.
	int i,j, chip;
	SetDataDirOut();
	for(chip=1;chip<3;chip++) // Mindkét képernyõfélre ugyan azt hajtjuk végre.
	{
		if(chip==1) SelectChip1();
		else SelectChip2();
		// Üres byte-ok kivitele.
		for(i=0;i<8;i++)
		{
			SetInstructionReg();
			WriteData(PAGE_ADDRESS+i);
			WriteData(COLUMN_ADDRESS);
			SetDataReg();
			for(j=0;j<64;j++)	WriteData(0x00);
		}
	}

	// Beállítjuk a szöveg mezõket
	Text1 = "     ";
	Text2 = "    ";
	DrawTable(PATTERN_ON,SCROLL); 	// Kirajzoljuk a játékteret a kétoldali szimbólumokkal és szövegekkel együtt.
									// A bábukat megjelenítjük, és engedélyezzük a csúsztató animációt.
}
void DrawTable(uint8_t PatternOn, uint8_t Scroll)
{
	/*
	 * PatternOn: PATTERN_OFF érték esetén csak a tábla rajzolódik ki bábuk nélkül
	 * Scroll: NO_SCROLL esetén nincs csúsztató animáció
	 */
	// Reverse: Azt adja meg, hogy melyik játékos szemszögébõl kell kirajzolni a táblát.
	int i,j,k;
	SetDataDirOut();

	for(i=0;i<8;i++) 	// soronként kirajzoljuk a táblát és az esetleges oldalsó szövegeket
						// A bábuk helyzetét a game.c-ben található Table tömb tartalmazza.
	{
		if(i == 7-PLAYER_SIGNAL_LINE) ShowPlayerSignal(ActualPlayer);
		else if(i==7-MESSAGE1_LINE) ShowMessage(MESSAGE1_LINE,1,Text1,5);
		else if(i==7-MESSAGE2_LINE) ShowMessage(MESSAGE2_LINE,1,Text2,4);

		// Chip2
		SelectChip2();
		SetInstructionReg();
		WriteData(PAGE_ADDRESS+i);
		WriteData(COLUMN_ADDRESS+32);// Kurzor pozícionálása
		if(Scroll) WriteData(DISPLAY_START_LINE+(8+i*8)%64); // A kezdõ sor kijelölése a memóriában.
		SetDataReg();
		for(j=0;j<4;j++)
		{
			FigureType  id= PatternOn ? (Reverse ? Table[i][j] :  Table[7-i][7-j]) : URES;
			for(k=0;k<8;k++) WriteData(Pattern[id][k]);
		}
		// Chip1
		SelectChip1();
		SetInstructionReg();
		WriteData(PAGE_ADDRESS+i);
		WriteData(COLUMN_ADDRESS);
		if(Scroll) WriteData(DISPLAY_START_LINE+(8+i*8)%64);
		SetDataReg();
		for(j=0;j<4;j++)
		{
			FigureType  id= PatternOn ? (Reverse ? Table[i][4+j] : Table[7-i][3-j]) : URES;
			for(k=0;k<8;k++) WriteData(Pattern[id][k]);
		}
		// Csúsztatás
		if(Scroll){
		volatile int kk,jj,m;
		//Csúsztatás
		for(m=1;m<8 && i<7 ;m+=3)
		{
			for(kk=0;kk<60000;kk++)
				for(jj=0;jj<10;jj++);
			SetInstructionReg();
			SelectChip1();
			WriteData(DISPLAY_START_LINE+(8+i*8+m)%64);
			SelectChip2();
			WriteData(DISPLAY_START_LINE+(8+i*8+m)%64);
		}// for
		}// if
	}
	MoveCursor(CursorX,CursorY);
}

// Egy adott mezõt rajzolunk ki az LCD-re
// x,y: koordináták. A bel felsõ sarok a (0,0)
// figure: a mezõbe rajzolandó bábu típusa
// Mask: A bábu mintázatából és ebbõl a bájtból XOR mûvelettel képzett biteket írjuk ki a kijelzõre. (A kurzort jelezzük ezzel.)
void DrawMaze(uint8_t x, uint8_t y, FigureType figure, uint8_t Mask)
{
	assert(IS_COORD_VALID(x,y));

	if(!Reverse)
	{
		if(x<4) SelectChip1();
		else SelectChip2();
	}
	else
	{
		if(x<4) SelectChip2();
		else SelectChip1();
	}

	SetInstructionReg();
	if(!Reverse)
	{
		WriteData(PAGE_ADDRESS+7-y);
		if(x<4) WriteData(COLUMN_ADDRESS+24-8*x);
		else WriteData(COLUMN_ADDRESS +56-8*(x-4));
	}
	else
	{
		WriteData(PAGE_ADDRESS+y);
		if(x<4) WriteData(COLUMN_ADDRESS +32+8*x);
		else WriteData(COLUMN_ADDRESS+8*(x-4));
	}

	SetDataReg();
	int k;
	for(k=0;k<8;k++) WriteData(Pattern[figure][k]^Mask);
}

void MoveCursor(uint8_t x, uint8_t y)
{
	if(x>7 || y>7) return;
	DrawMaze(CursorX,CursorY,Table[CursorY][CursorX],NO_INVERT); //A régi mezõt újra kirajzolom invertálás nélkül.
	DrawMaze(x,y,Table[y][x],INVERT); // Az új mezõt invertálva frissítem.

	CursorX = x; // Átírjuk a kurzor új pozícióját.
	CursorY = y;
}

void CarryFigure(uint8_t x, uint8_t y) // A kurzorral egy felvett bábut viszünk, így az jelenik meg a kiválasztott helyen.
{
	if(x>7 || y>7) return;
	DrawMaze(CursorX,CursorY,Table[CursorY][CursorX],NO_INVERT); //Az elõzõleg kiválasztott mezõt újra rajzolom a saját tartalmával.
	DrawMaze(x,y,CarriedFigure,INVERT); // Az új mezõre a felvett bábut rajzolom invertálva.
	CursorX = x;
	CursorY = y;
}
void MoveCursorRight()
{
	MoveCursor(CursorX+1,CursorY);
}
void MoveCursorLeft()
{
	MoveCursor(CursorX-1,CursorY);
}

void MoveCursorUp()
{
	MoveCursor(CursorX,CursorY-1);
}

void MoveCursorDown()
{
	MoveCursor(CursorX,CursorY+1);
}

void CarryFigureRight()
{
	CarryFigure(CursorX+1,CursorY);
}
void CarryFigureLeft()
{
	CarryFigure(CursorX-1,CursorY);
}

void CarryFigureUp()
{
	CarryFigure(CursorX,CursorY-1);
}

void CarryFigureDown()
{
	CarryFigure(CursorX,CursorY+1);
}

/* 5x8-as karakterminták
 * Mivel az LCD fejjel lefelé van a panelon, így a byte-ok tükrözve lettek, továbbá az oszlopos sorrendje is fel van cserélve.
 */

#define ASCII_START 32 // Csak a 32-ik bejegyzéstõl valósítjuk meg az ASCII táblát, elõtte csak vezérlõ karakterek vannak.
#define CHAR_SPACE 1 // Ennyi oszlop helyet hagyunk a karakterek között.
const char ASCII[] = {
		0x00,0x00,0x00,0x00,0x00,      //
		0x00,0x00,0xfa,0x00,0x00,      //!
		0x00,0xc0,0x00,0xc0,0x00,      //"
		0x28,0x7c,0x28,0x7c,0x28,      //#
		0x48,0x54,0xfe,0x54,0x24,      //$
		0x86,0x66,0x10,0xcc,0xc2,      //%
		0x0a,0x44,0xaa,0x92,0x6c,      //&
		0x00,0x00,0xc0,0xa0,0x00,      //'
		0x00,0x82,0x44,0x38,0x00,      //(
		0x00,0x38,0x44,0x82,0x00,      //)
		0x28,0x10,0x7c,0x10,0x28,      //*
		0x10,0x10,0x7c,0x10,0x10,      //+
		0x00,0x00,0x0c,0x0a,0x00,      //,
		0x10,0x10,0x10,0x10,0x10,      //-
		0x00,0x00,0x06,0x06,0x00,      //.
		0x40,0x20,0x10,0x08,0x04,      ///
		0x7c,0xa2,0x92,0x8a,0x7c,      //0
		0x00,0xfe,0x40,0x20,0x00,      //1
		0x62,0x92,0x8a,0x86,0x42,      //2
		0x6c,0x92,0x92,0x82,0x44,      //3
		0x08,0xfe,0x48,0x28,0x18,      //4
		0x9c,0xa2,0xa2,0xa2,0xe4,      //5
		0x4c,0x92,0x92,0x92,0x7c,      //6
		0xe0,0x90,0x8e,0x80,0x80,      //7
		0x6c,0x92,0x92,0x92,0x6c,      //8
		0x7c,0x92,0x92,0x92,0x64,      //9
		0x00,0x00,0x6c,0x6c,0x00,      //:
		0x00,0x00,0x6c,0x6a,0x00,      //;
		0x00,0x82,0x44,0x28,0x10,      //<
		0x28,0x28,0x28,0x28,0x28,      //=
		0x10,0x28,0x44,0x82,0x00,      //>
		0x60,0x90,0x8a,0x80,0x40,      //?
		0x7a,0xaa,0x9a,0x82,0x7c,      //@
		0x7e,0x90,0x90,0x90,0x7e,      //A
		0x6c,0x92,0x92,0x92,0xfe,      //B
		0x44,0x82,0x82,0x82,0x7c,      //C
		0x7c,0x82,0x82,0x82,0xfe,      //D
		0x82,0x92,0x92,0x92,0xfe,      //E
		0x80,0x90,0x90,0x90,0xfe,      //F
		0x5c,0x92,0x82,0x82,0x7c,      //G
		0xfe,0x10,0x10,0x10,0xfe,      //H
		0x00,0x82,0xfe,0x82,0x00,      //I
		0xfc,0x02,0x02,0x02,0x0c,      //J
		0x82,0x44,0x28,0x10,0xfe,      //K
		0x02,0x02,0x02,0x02,0xfe,      //L
		0xfe,0x40,0x30,0x40,0xfe,      //M
		0xfe,0x10,0x20,0x40,0xfe,      //N
		0x7c,0x82,0x82,0x82,0x7c,      //O
		0x60,0x90,0x90,0x90,0xfe,      //P
		0x7a,0x84,0x84,0x84,0x78,      //Q
		0x6e,0x90,0x90,0x90,0xfe,      //R
		0x4c,0x92,0x92,0x92,0x64,      //S
		0x80,0x80,0xfe,0x80,0x80,      //T
		0xfc,0x02,0x02,0x02,0xfc,      //U
		0xf8,0x04,0x02,0x04,0xf8,      //V
		0xfe,0x04,0x08,0x04,0xfe,      //W
		0x82,0x44,0x38,0x44,0x82,      //X
		0xe0,0x10,0x0e,0x10,0xe0,      //Y
		0xc2,0xa2,0x92,0x8a,0x86,      //Z
		0x3c,0x82,0x02,0x82,0x3c,      //[ Valójában: Ü
		0x04,0x08,0x10,0x20,0x40,      //'\'
		0x1c,0xA2,0x22,0xA2,0x1c,      //] Valójában Ö
		0x20,0x40,0x80,0x40,0x20,      //^
		0x02,0x02,0x02,0x02,0x02,      //_
		0x00,0x20,0x40,0x80,0x00,      //`
		0x1e,0x2a,0x2a,0x2a,0x04,      //a
		0x1c,0x22,0x22,0x22,0xfe,      //b
		0x22,0x22,0x22,0x22,0x1c,      //c
		0xfe,0x22,0x22,0x22,0x1c,      //d
		0x18,0x2a,0x2a,0x2a,0x1c,      //e
		0xa0,0xa0,0x7e,0x20,0x20,      //f
		0x3c,0x2a,0x2a,0x2a,0x10,      //g
		0x1e,0x20,0x20,0x10,0xfe,      //h
		0x00,0x02,0xbe,0x22,0x00,      //i
		0x00,0xbc,0x22,0x02,0x04,      //j
		0x00,0x22,0x14,0x08,0xfe,      //k
		0x00,0x02,0xfe,0x82,0x00,      //l
		0x1e,0x20,0x1e,0x20,0x3e,      //m
		0x1e,0x20,0x20,0x10,0x3e,      //n
		0x1c,0x22,0x22,0x22,0x1c,      //o
		0x10,0x28,0x28,0x28,0x3e,      //p
		0x3e,0x28,0x28,0x28,0x10,      //q
		0x20,0x20,0x10,0x3e,0x00,      //r
		0x04,0x2a,0x2a,0x2a,0x12,      //s
		0x22,0x22,0xfc,0x20,0x20,      //t
		0x3e,0x04,0x02,0x02,0x3c,      //u
		0x38,0x04,0x02,0x04,0x38,      //v
		0x3c,0x02,0x0c,0x02,0x3c,      //w
		0x22,0x14,0x08,0x14,0x22,      //x
		0x3c,0x0a,0x0a,0x0a,0x30,      //y
		0x22,0x32,0x2a,0x26,0x22,      //z
		0x82,0x82,0x6c,0x10,0x00,      //{
		0x00,0x00,0xfe,0x00,0x00,      //|
		0x00,0x10,0x6c,0x82,0x82,      //}
		0x40,0x20,0x40,0x80,0x40      //~
};
/*
 * Szöveget jelenít meg a képernyõ két oldalsó részén.
 * Line: A cél sor száma. Felülrõl számoljuk 0-tól kezdve.
 * Offset: Balról üresen hagyott oszlopok száma.
 * Text: Szöveg
 * Length: A kijelzendõ karakterek száma.
 */
void ShowMessage(uint8_t Line, uint8_t Offset,char *Text, uint8_t Length, uint8_t Side)
{
	int ch,seg,m;
	for(m=0;m<2;m++) // Mindkét oldalra kiírjuk a szöveget.
	{
		if(m==0 && (Side & SIDE_LEFT)) SelectChip1();
		else if(m == 1 && (Side & SIDE_RIGHT))  SelectChip2();
		else continue;

		SetInstructionReg();
		// Kurzor pozícionálása.
		WriteData(PAGE_ADDRESS+7-Line);
		WriteData(COLUMN_ADDRESS+64-32*m -Offset - Length*(5+CHAR_SPACE));
		SetDataReg();
		for(ch=0;ch<Length;ch++) //Végigmegyünk a szöveg elsõ megadott számú karakterén.
		{
			for(seg=0;seg<CHAR_SPACE;seg++) WriteData(0x00); // Karakterek közti szünetek.
			for(seg=0;seg<5;seg++) // A karaktermintázat oszlopai
				WriteData(ASCII[ (Text[Length-ch-1]-ASCII_START)*5+seg]); // A szövege hátulról kell kiírni, mivel az LCD fejjel lefelé van.
		}
	}
}
